---
title: "Design Motivation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Design Motivation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The motivating idea behind this package is that every data point has context,
and an object storing data points should provide access to this context. The
`data.frame` object enables this to some extent by allowing us to annotate
data points with labels (the `"row.names"`), but it is not flexible
enough to handle cases where the context involves more than one attribute. We
fix this by replacing the `"row.names"` attribute of a `data.frame` with a new
attribute, `"key"`, that stores potentially multi-column attributes
(*composite keys*) that identify each row in the data frame.


We view a *variable* as a map (function) between two sets, called the *frame*
(domain) and the *type* (domain) of the variable. We refer to members of the
*frame* as *keys* and members of the *type* as *values*. A *data point* is a
(variable, key, value) triple. In standard statistical notation, the triple
$(x, i, x_i)$ would be a data point; this often gets abbreviated as $x_i$
since it is clear from the that $i$ is the key and $x$ is the variable.

A *sample* is a collection of data points with a common variable.


## Keys

### Constraints

For simplicity, we will require that key values be valid UTF-8 strings. There
are two reasons for this constraint:

 1. To use keys as as object names, it will be necessary to convert them to
    strings.

 2. To distinguish access-by-key from access-by-index, keys cannot have type
    `integer` or `double`. The expression `x[3,]` needs to unambigously
    refer to the third row in `x`, not the row with key 3.

Requiring that keys be strings may impose some efficiency penalty (both time
and space). If it can be demonstrated that the penalty is substantial, then in
the future we may allow for integer keys, using a special key class do make
indexing operations unambiguous.


Beyond the type constraints, we require that each key (or composite key in the
case of multi-attribute keys) correspond to a single data point. To this end,
we require that the keys (or composite keys) be unique non-missing values.  We
do not require that keys be unique after Unicode normalization, and we allow
the empty string (`""`) as a key value.


### Component names

An `m`-attribute key can optionally have names for the attributes. For
example, if we key a set of hourly measurements by a two-component key, we can
optionally name these components, say `"day"` and `"hour"`. It is not
necessary that we give the components names. Making component names optional
allows us to seamlessly convert between, say, a matrix with row and column
names, and a keyed data set with a two-component key corresponding to the row
and column indices. Allowing anonymous keys also allows us to convert
from a `data.frame` with `row.names` to a keyed data set with an anonymous
key (taken from the `row.names`).


### Conversion to string

For compatibility with other R objects that support `"names"`
but not composite keys, it is essential to have a well-defined mapping between
composite keys and string representations of them. For a scalar key `k`, we
use they key itself as its string representation. For composite key
`(k1, k2, ..., km)`, we first escaping reverse solidus (`\`, U+005C) and
comma (`,`, U+002C) by preceding these characters with a reverse solidus.
The `key_escape` function performs the escaping, and the `key_unescape`
function reverses it:

```{r}
key_escape(c("Jones, Henrietta", "\\/", ",,,"))
key_unescape(c("Jones\\, Henrietta", "\\\\/", "\\,\\,\\,"))
```

We then concatenate the escaped strings `s1, s2, ..., sm` together, separating
the components with unescaped commas. The `key_encode` function performs the
conversion for us, and the `key_decode` with `composite = TRUE`  (the default)
reverses it:

```{r}
# 3-component composite key
(s <- key_encode(list(c("Jones, Henrietta", "X, Mx.", "Box, George"),
                      c("\\/", "", "2\\b"),
                      c("92", "2", "17"))))
key_decode(s)
```

Note, that for scalar keys we do not escape reverse solidus and
comma characters. Thus, the string "Jones, Henrietta" cannot unambiguously
be decoded to a key without knowing whether the key is composite or not:

```{r}
key_decode("Jones, Henrieta")
key_decode("Jones, Henrieta", composite = FALSE)
```

This ambiguity is unfortunate, but as we will see in the sequel, this
ambiguity is necessary if we want indexing to behave consistently with scalar
and composite keys.


## Data tables

A `data_table` is a matrix-like structure storing a set of variables measured
on a collection of individuals. We identify the individuals with rows of the
table, and the variables with the columns. We implement the `data_table` as as
subclass of `data.frame` with better support for matrix columns and the
ability to specify keys to identify the rows.

The `data_table` type is an extension of `data.frame` that allows specifying
keys for the rows. We construct a data table as in the following example:

```{r}
x <- data_table(a = letters, b = rnorm(26), c = 2 * b)
```

Columns are evaluated sequentially in an environment that includes the
preceding values. Columns can be vector-like or matrix-like (having one or two
dimensions). At construction time, we can specify that one or more of the
columns should be used for the key by giving their names to the `key`
argument:

```{r}
y <- data_table(a = letters, b = rnorm(26), c = 2 * b, key = c("c", "a"))
```




## Indexing

### Logical or numeric subscript

For dataset `x` and logical vector `i`, the indexing operations `x[i,]` and
`x[i,j]` behave like the counterpart `data.frame` operations, except that
`drop = FALSE` is the default.


With integer vector `i`, the indexing operation `x[i,]` returns the rows of
`x` with indices in `i` in the order of their appearances in `i`. When `x` is
unkeyed, then `i` can contain duplicates, in which case the corresponding rows
are duplicated in the result. This behavior is the same was with a
`data.frame`. When `x` has a key, however, `i` is not allowed to contain
duplicates; otherwise we would need to assign new keys to the duplicated rows
and there is no satisfactory way of doing this in general, especially for
composite keys. The operation `x[i,j]` behaves similarly.


### Key subscript

When `i` is not numeric or logical, we 
